<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Doubly-linked list: Doubly-linked list</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Doubly-linked list
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Doubly-linked list</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple doubly-linked list implementation.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:doubly-linked__list_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="doubly-linked__list_8h.html">doubly-linked_list.h</a></td></tr>
<tr class="memdesc:doubly-linked__list_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple doubly-linked list implementation. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:structdlList__node"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a></td></tr>
<tr class="memdesc:structdlList__node"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node.  <a href="group__doublyLinkedList.html#structdlList__node">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structdlList.html">dlList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Doubly-linked list.  <a href="structdlList.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga0b709b7b1354060ce3c878865ec7ca06"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga0b709b7b1354060ce3c878865ec7ca06">dlList_returnValues</a> { <a class="el" href="group__doublyLinkedList.html#gga0b709b7b1354060ce3c878865ec7ca06af460ed320c9b86e754a2435c66c5b720">DLLIST_OK</a> =  0, 
<a class="el" href="group__doublyLinkedList.html#gga0b709b7b1354060ce3c878865ec7ca06a0745ae1c6ebd9c201a659e1b7c168b45">DLLIST_ERR_errArg</a>, 
<a class="el" href="group__doublyLinkedList.html#gga0b709b7b1354060ce3c878865ec7ca06ae72c02a4435ba7bb440083afaf9defbf">DLLIST_ERR_malloc</a>, 
<a class="el" href="group__doublyLinkedList.html#gga0b709b7b1354060ce3c878865ec7ca06aae343538cb13da9e76d4774fb1904d2e">DLLIST_ERR_undefFunc</a>
 }</td></tr>
<tr class="memdesc:ga0b709b7b1354060ce3c878865ec7ca06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return values.  <a href="group__doublyLinkedList.html#ga0b709b7b1354060ce3c878865ec7ca06">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga43d27cccedde8d0523c844d9d650461f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga43d27cccedde8d0523c844d9d650461f">dlList_init</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, void(*destroyFunction)(void *data), int(*compareFunction)(const void *data1, const void *data2), void *(*dataDeepCopyFunction)(const void *data))</td></tr>
<tr class="memdesc:ga43d27cccedde8d0523c844d9d650461f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialise a doubly-linked list object.  <a href="#ga43d27cccedde8d0523c844d9d650461f"></a><br/></td></tr>
<tr class="memitem:ga38a39f0bbe7493011ca09dce82736a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga38a39f0bbe7493011ca09dce82736a40">dlList_destroy</a> (struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:ga38a39f0bbe7493011ca09dce82736a40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a doubly-linked list.  <a href="#ga38a39f0bbe7493011ca09dce82736a40"></a><br/></td></tr>
<tr class="memitem:gafa9b49d51560b427ebf24bbd23267b99"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#gafa9b49d51560b427ebf24bbd23267b99">dlList_insertBefore</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *beforeNode, void *data)</td></tr>
<tr class="memdesc:gafa9b49d51560b427ebf24bbd23267b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node before another node.  <a href="#gafa9b49d51560b427ebf24bbd23267b99"></a><br/></td></tr>
<tr class="memitem:ga38782e913cd725bd6fb4343508055885"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga38782e913cd725bd6fb4343508055885">dlList_insertAfter</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *afterNode, void *data)</td></tr>
<tr class="memdesc:ga38782e913cd725bd6fb4343508055885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node after another node.  <a href="#ga38782e913cd725bd6fb4343508055885"></a><br/></td></tr>
<tr class="memitem:ga0b8157db32242be21f477d16d013420d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga0b8157db32242be21f477d16d013420d">dlList_insertOrdered</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, void *data)</td></tr>
<tr class="memdesc:ga0b8157db32242be21f477d16d013420d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node in a sorted list.  <a href="#ga0b8157db32242be21f477d16d013420d"></a><br/></td></tr>
<tr class="memitem:ga3e8dabb46570ec579f13b4dde6456131"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga3e8dabb46570ec579f13b4dde6456131">dlList_append</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, void *data)</td></tr>
<tr class="memdesc:ga3e8dabb46570ec579f13b4dde6456131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a new node at the end of a list.  <a href="#ga3e8dabb46570ec579f13b4dde6456131"></a><br/></td></tr>
<tr class="memitem:gaa3dd3c8e2761cf0d6d158ccf2c978663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#gaa3dd3c8e2761cf0d6d158ccf2c978663">dlList_remove</a> (struct <a class="el" href="structdlList.html">dlList</a> *list, struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *node, void **data)</td></tr>
<tr class="memdesc:gaa3dd3c8e2761cf0d6d158ccf2c978663"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node from a list.  <a href="#gaa3dd3c8e2761cf0d6d158ccf2c978663"></a><br/></td></tr>
<tr class="memitem:ga2eeb35a8150f53e972e9b43d626d504e"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga2eeb35a8150f53e972e9b43d626d504e">dlList_find</a> (const struct <a class="el" href="structdlList.html">dlList</a> *list, const void *key)</td></tr>
<tr class="memdesc:ga2eeb35a8150f53e972e9b43d626d504e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search for a node in a list.  <a href="#ga2eeb35a8150f53e972e9b43d626d504e"></a><br/></td></tr>
<tr class="memitem:ga385870c73193ac719f13462149e511ed"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structdlList.html">dlList</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga385870c73193ac719f13462149e511ed">dlList_copy</a> (const struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:ga385870c73193ac719f13462149e511ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a duplicate of a list.  <a href="#ga385870c73193ac719f13462149e511ed"></a><br/></td></tr>
<tr class="memitem:ga6c78cfad15b00ebd954245b2a974523a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga6c78cfad15b00ebd954245b2a974523a">dlList_appendList</a> (struct <a class="el" href="structdlList.html">dlList</a> *list1, const struct <a class="el" href="structdlList.html">dlList</a> *list2)</td></tr>
<tr class="memdesc:ga6c78cfad15b00ebd954245b2a974523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append one list to another.  <a href="#ga6c78cfad15b00ebd954245b2a974523a"></a><br/></td></tr>
<tr class="memitem:ga6c6947a851892455db6c1fa534853d1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga6c6947a851892455db6c1fa534853d1d">dlList_sort</a> (struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:ga6c6947a851892455db6c1fa534853d1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a list.  <a href="#ga6c6947a851892455db6c1fa534853d1d"></a><br/></td></tr>
<tr class="memitem:ga35afa83381b2e1ecd9ba0d7ed95f93a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ga35afa83381b2e1ecd9ba0d7ed95f93a9"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#ga35afa83381b2e1ecd9ba0d7ed95f93a9">dlList_size</a> (const struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:ga35afa83381b2e1ecd9ba0d7ed95f93a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes in list. <br/></td></tr>
<tr class="memitem:gadd86bfae1672a981a7baf19d7284e82b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadd86bfae1672a981a7baf19d7284e82b"></a>
struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#gadd86bfae1672a981a7baf19d7284e82b">dlList_first</a> (const struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:gadd86bfae1672a981a7baf19d7284e82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">First node in list. <br/></td></tr>
<tr class="memitem:gacb948fac5913e0e20e29dfeba421d073"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gacb948fac5913e0e20e29dfeba421d073"></a>
struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__doublyLinkedList.html#gacb948fac5913e0e20e29dfeba421d073">dlList_last</a> (const struct <a class="el" href="structdlList.html">dlList</a> *list)</td></tr>
<tr class="memdesc:gacb948fac5913e0e20e29dfeba421d073"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last node in list. <br/></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<p>A simple doubly-linked list implementation. </p>
<p>Supports sorting and user-defined node deep-copy and destroy functions. </p>
<hr/><h2>Class Documentation</h2>
<a name="structdlList__node" id="structdlList__node"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct dlList_node</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Node. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a class="anchor" id="adb2f91fd57f58ee7f2408a141cf0c388"></a>void *</td>
<td class="fieldname">
data</td>
<td class="fielddoc">
User data. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a30afa166b61143ff2495862f9248c1c2"></a>struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *</td>
<td class="fieldname">
next</td>
<td class="fielddoc">
Pointer to next node. </td></tr>
<tr><td class="fieldtype">
<a class="anchor" id="a7c520582d885a5902c76257cf23108ec"></a>struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *</td>
<td class="fieldname">
prev</td>
<td class="fielddoc">
Pointer to previous node. </td></tr>
</table>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga0b709b7b1354060ce3c878865ec7ca06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__doublyLinkedList.html#ga0b709b7b1354060ce3c878865ec7ca06">dlList_returnValues</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return values. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga0b709b7b1354060ce3c878865ec7ca06af460ed320c9b86e754a2435c66c5b720"></a>DLLIST_OK</em>&nbsp;</td><td>
<p>Everything went fine. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0b709b7b1354060ce3c878865ec7ca06a0745ae1c6ebd9c201a659e1b7c168b45"></a>DLLIST_ERR_errArg</em>&nbsp;</td><td>
<p>An erroneous argument was passed to the function. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0b709b7b1354060ce3c878865ec7ca06ae72c02a4435ba7bb440083afaf9defbf"></a>DLLIST_ERR_malloc</em>&nbsp;</td><td>
<p>Memory allocation failed. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="gga0b709b7b1354060ce3c878865ec7ca06aae343538cb13da9e76d4774fb1904d2e"></a>DLLIST_ERR_undefFunc</em>&nbsp;</td><td>
<p>An undefined function pointer was attempted called. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="ga3e8dabb46570ec579f13b4dde6456131"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_append </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node at the end of a list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">data</td><td>data to add to the new node</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL </td></tr>
    <tr><td class="paramname">DLLIST_ERR_malloc</td><td>if there was not enough memory to create a new<ul>
<li>node </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c78cfad15b00ebd954245b2a974523a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_appendList </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append one list to another. </p>
<p>This function copies all data from one list to another. Deep data copy will be performed of user data if the user-supplied copy() function is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list1</td><td>list to append data to </td></tr>
    <tr><td class="paramname">list2</td><td>list to fetch data from</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL </td></tr>
    <tr><td class="paramname">DLLIST_ERR_malloc</td><td>if there was not enough memory to create a new node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga385870c73193ac719f13462149e511ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structdlList.html">dlList</a> dlList_copy </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a duplicate of a list. </p>
<p>This function uses copy(), if defined, to deep-copy user data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an exact copy of the given list, unless list is NULL, in which case an empty list is returned. If a memory allocation error occurs, an empty list is returned </dd></dl>

</div>
</div>
<a class="anchor" id="ga38a39f0bbe7493011ca09dce82736a40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlList_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a doubly-linked list. </p>
<p>All nodes will be deleted, and destroy(), if defined, will be called on all user-supplised data</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2eeb35a8150f53e972e9b43d626d504e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a>* dlList_find </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">read</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Search for a node in a list. </p>
<p>The first node with data matching the given key will be return, or NULL if no node could be found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">key</td><td>data that will be compared to all node's data by using the user-supplied compare() function. Cannot be NULL</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a node object if a node was found, or NULL if no node could be found. NULL will also be returned if any erroneous arguments was supplied or if compare() is undefined </dd></dl>

</div>
</div>
<a class="anchor" id="ga43d27cccedde8d0523c844d9d650461f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlList_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *data)&#160;</td>
          <td class="paramname"><em>destroyFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int(*)(const void *data1, const void *data2)&#160;</td>
          <td class="paramname"><em>compareFunction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)(const void *data)&#160;</td>
          <td class="paramname"><em>dataDeepCopyFunction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialise a doubly-linked list object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">destroyFunction</td><td>pointer to a function that will be called whenever a node is destroyed. The supplied argument is the node data </td></tr>
    <tr><td class="paramname">compareFunction</td><td>pointer to a function that compares two instances of user data. It must return an integer less than, equal to, or greater than zero if the first argument is considered to be respectively less than, equal to or larger than the second </td></tr>
    <tr><td class="paramname">dataDeepCopyFunction</td><td>pointer to a function that creates a deep copy of user data. If NULL, data will be shared and not copied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38782e913cd725bd6fb4343508055885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_insertAfter </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td>
          <td class="paramname"><em>afterNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node after another node. </p>
<p>Insert a new node after the given node. The given node must exist if the list is non-empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">afterNode</td><td>the node to insert the new node after </td></tr>
    <tr><td class="paramname">data</td><td>data to add to the new node</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL or if the list is non-empty and afterNode is NULL </td></tr>
    <tr><td class="paramname">DLLIST_ERR_malloc</td><td>if there was not enough memory to create a new node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafa9b49d51560b427ebf24bbd23267b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_insertBefore </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td>
          <td class="paramname"><em>beforeNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node before another node. </p>
<p>Insert a new node before the given node. The given node must exist if the list is non-empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">beforeNode</td><td>the node to insert the new node in front of </td></tr>
    <tr><td class="paramname">data</td><td>data to add to the new node</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL or if the list is non-empty and beforeNode is NULL </td></tr>
    <tr><td class="paramname">DLLIST_ERR_malloc</td><td>if there was not enough memory to create a new node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0b8157db32242be21f477d16d013420d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_insertOrdered </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a new node in a sorted list. </p>
<p>The new node will be inserted so that the list will remain sorted by using the user-supplied compare() function. The compare() function must be defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">data</td><td>data to add to the new node</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL </td></tr>
    <tr><td class="paramname">DLLIST_ERR_undefFunc</td><td>if compare() is undefined </td></tr>
    <tr><td class="paramname">DLLIST_ERR_malloc</td><td>if there was not enough memory to create a new<ul>
<li>node </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa3dd3c8e2761cf0d6d158ccf2c978663"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dlList_remove </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="group__doublyLinkedList.html#structdlList__node">dlList_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a node from a list. </p>
<p>Remove the given node, destroy user data if destroy() is defined and data is NULL. If data is non-NULL, the data from the node that is to be removed will be set to the given pointer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
    <tr><td class="paramname">node</td><td>node to remove. Must exist </td></tr>
    <tr><td class="paramname">pointer</td><td>to user data. If non-NULL, it will contain the user data of the node to remove. If NULL, and if destroy() is defined, user data will be destroyed by calling destroy( node-&gt;data )</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">DLLIST_OK</td><td>if no problems occurred </td></tr>
    <tr><td class="paramname">DLLIST_ERR_errArg</td><td>if list is NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6c6947a851892455db6c1fa534853d1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dlList_sort </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structdlList.html">dlList</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort a list. </p>
<p>The user must have supplied a compare() function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>doubly-linked list object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jul 19 2013 19:32:09 for Doubly-linked list by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.1.2
</small></address>
</body>
</html>
